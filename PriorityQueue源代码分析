这是一个基于优先堆的优先队列，里面的元素都是按照每个对象实现的comparable接口来排列，或者按照在构造优先队列时的提供的Comparator实例来排序，
队列的第一个元素是排序中的最小元素，优先队列的大小没有进行限制，但是它有一个容量capacity用于限制在队列中存储的元素数量，capacity的大小总是和队列中存储的
元素数量相等，随着元素不断添加进入优先队列，它的capacity将会自动进行增长
需要注意的是，本优先队列实现的iterator方法不能保证按照特定的顺序遍历所有的优先队列元素，同时本优先队列方法都不是线程安全的，如果需要线程安全的优先队列，可以使用
PriorityBlockingQueue来实现，下面是PriorityQueue源代码分析：
public class PriorityQueue<E> extends AbstractQueue<E>中的重要成员变量有：
    private static final int DEFAULT_INITIAL_CAPACITY = 11;
    transient Object[] queue; // non-private to simplify nested class access 这里的queue使用的是非私有方法，为了让嵌套类可以更加方便的访问
    private final Comparator<? super E> comparator; //如果为空那么将会使用类的自带comparable方法
     transient int modCount = 0; 记录本对象结构被改变的次数，如扩容
 扩容代码：
     一些jvm的实现会在数组对象头中保留几个字节，如果超过下面的数值分配数组内存，将会导致outofmemoryerror
     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
     扩容源代码：
     private void grow(int minCapacity) {
        int oldCapacity = queue.length;
        // Double size if small; else grow by 50%
        int newCapacity = oldCapacity + ((oldCapacity < 64) ?
                                         (oldCapacity + 2) :
                                         (oldCapacity >> 1));
        // overflow-conscious code
        //如果增长后的容量大于最大数组容量，那么将会调用hugeCapacity方法，根据minCapacity来扩
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        queue = Arrays.copyOf(queue, newCapacity);
    }
      
      private static int hugeCapacity(int minCapacity) {
        //此时minCapacity的大小已为负数，说明已经溢出了
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
            //如果原先需要保证的容量已经超过了最大数组容量，那么直接复制最大数值，否则赋值安全数组容量
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
heapify方法：
    private void heapify() {
       //从最后一个非叶子节点开始形成最小堆
        for (int i = (size >>> 1) - 1; i >= 0; i--)
            siftDown(i, (E) queue[i]);
    }
        private void siftDown(int k, E x) {
        //如果comparator对象不为空
        if (comparator != null)
            siftDownUsingComparator(k, x);
        else
            siftDownComparable(k, x);
    }
      private void siftDownComparable(int k, E x) {
        Comparable<? super E> key = (Comparable<? super E>)x;
        int half = size >>> 1;        // loop while a non-leaf
        while (k < half) {
             //先假设左节点为最小的
            int child = (k << 1) + 1; // assume left child is least
            Object c = queue[child];
            int right = child + 1;
            //判断右节点的大小
            if (right < size &&
                ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)
                c = queue[child = right];
             //说明已经形成了最小堆
            if (key.compareTo((E) c) <= 0)
                break;
            queue[k] = c;
            k = child;
        }
        queue[k] = key;
    }
offer方法，加入队列：
    public boolean offer(E e) {
        if (e == null)
            throw new NullPointerException();
        modCount++;
        int i = size;
        //i的值已经达到了数组的容量了，此时数组需要进行扩容
        if (i >= queue.length)
            grow(i + 1);
        size = i + 1;
        if (i == 0)
            queue[0] = e;
        else
            //新加入的元素向堆顶移动
            siftUp(i, e);
        return true;
    }
     
    private void siftUpComparable(int k, E x) {
        Comparable<? super E> key = (Comparable<? super E>) x;
        while (k > 0) {
            //获得父亲节点
            int parent = (k - 1) >>> 1;
            Object e = queue[parent];
            //如果大于父亲节点，说明新加入的元素可以形成小顶堆，退出循环
            if (key.compareTo((E) e) >= 0)
                break;
            queue[k] = e;
            k = parent;
        }
        queue[k] = key;
    }
